#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения командв потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;

#!csharp

public interface ICommand
{
    void Execute();
}


public class TestCommand(int id) : ICommand
{
    int counter = 0;

    public void Execute()
    {
        Console.WriteLine($"Поток {id} вызов {++counter}");
    }
}

#!csharp

public class TaskScheduler
{
    private readonly BlockingCollection<ICommand> _commands = new BlockingCollection<ICommand>();
    private CancellationTokenSource _cts = new CancellationTokenSource();
    private Task _task;

    public TaskScheduler()
    {
        _task = Task.Run(() => ProcessCommands(_cts.Token));
    }

    private void ProcessCommands(CancellationToken token)
    {
        try
        {
            foreach (var command in _commands.GetConsumingEnumerable(token))
            {
                command.Execute();
            }
        }
        catch (OperationCanceledException)
        {
            // Handle the cancellation
        }
    }

    public void AddCommand(ICommand command)
    {
        _commands.Add(command);
    }

    public void HardStop()
    {
        _cts.Cancel();
        _commands.CompleteAdding();
        try
        {
            _task.Wait();
        }
        catch (AggregateException ae)
        {
            ae.Handle(e => e is OperationCanceledException);
        }
    }
}

#!csharp

TaskScheduler scheduler = new TaskScheduler();

for (int i = 0; i < 5; i++)
{
    var command = new TestCommand(i);
    for (int j = 0; j < 3; j++)
    {
        scheduler.AddCommand(command);
    }
}

Thread.Sleep(1000); // Даем немного времени на выполнение команд

scheduler.HardStop();
