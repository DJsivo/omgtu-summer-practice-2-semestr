#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System.Threading;
public class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber) 
{ 
    Barrier barrier = new Barrier(threadsnumber);
    double s = 0;
    Parallel.For(0, threadsnumber, (ts) =>
    {
        double ss = 0;
        for (int i = ts; i < Convert.ToInt32((b - a) / step); i += threadsnumber)
        {
            ss += (function(a + i * step) + function(a + (i + 1) * step))*step / 2;
        }
        Interlocked.Exchange(ref s, s + ss);
        barrier.SignalAndWait();
    });

    return s;
}
}

#!csharp

#r "nuget: xunit, 2.8.1"
#r "nuget:ScottPlot, 5.0.36"
using Microsoft.DotNet.Interactive.Formatting;
using Xunit;
using System.Diagnostics;

using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);


var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);
Stopwatch stopwatch = new Stopwatch();

//Оптимальный шаг.
public void Steep(double st)
{
    stopwatch.Reset();
    stopwatch.Start();
    //Assert.Equal(0, DefiniteIntegral.Solve(-100, 100, SIN, st, 8), 1e-4);
    var r = DefiniteIntegral.Solve(-100, 99, SIN, st, 1);
    stopwatch.Stop();
    Console.WriteLine(@$"{r}
    step: {st}
    {stopwatch.ElapsedTicks} "); 
}
Console.WriteLine("Steps");
Steep(1e-1);
Steep(1e-2);//
Steep(1e-3);
Steep(1e-4);
Steep(1e-5);
Steep(1e-6);

//Потоки.
List<double> potok = new();
List<double> time = new();

public void Threaad(int pot)
{
    stopwatch.Reset();
    stopwatch.Start();
    var r = DefiniteIntegral.Solve(-100, 99, SIN, 1e-2, pot);/////
    stopwatch.Stop();
    Console.WriteLine(@$"{r}
    {stopwatch.ElapsedTicks} "); 
    potok.Add(pot);
    time.Add(stopwatch.ElapsedTicks);
}
Console.WriteLine("Threads");
for (int i = 1; i <= 16; i++)
{
    Threaad(i);
}//Чаще всего оптимально было 2 (прмерно за 30 запусков)
//Tab
ScottPlot.Plot plt = new();
double[] dataX = time.ToArray();
double[] dataY = potok.ToArray();
plt.Add.Scatter(dataX, dataY);
plt.SavePng("quickstart.png", 400, 300);
plt

#!csharp

using System.Diagnostics;
var SIN = (double x) => Math.Sin(x);
//однопоток
public double OSolve(double a, double b, Func<double, double> f, double dx)
{

    double eps = 10E-7;
    if(!double.IsNormal(a)||!double.IsNormal(b)||dx<eps)throw new ArgumentException();
    double cp=a;
    return Enumerable.Range(0, Convert.ToInt32((b - a) / dx))
        .Select(i => a + dx * i)
        .Sum(cp => Math.Abs(((f(cp) + f(cp + dx)) * dx) / 2));
}
var stopwatch1 = Stopwatch.StartNew();
OSolve(-100, 99, SIN, 1e-2);
stopwatch1.Stop();
var s1 = stopwatch1.ElapsedTicks;

var stopwatch2 = Stopwatch.StartNew();
DefiniteIntegral.Solve(-100, 99, SIN, 1e-2, 2);////
stopwatch2.Stop();
var s2 = stopwatch2.ElapsedTicks;
Console.WriteLine(@$"Для однопотока: {s1}
Для опт многопотока:{s2}
")

#!markdown

**Summary**
1. Оптимальный шаг: 1e-2 
2. Оптимальное кол-во потоков: 2
3. Скорость оптимальной многопоточной: 2530 tc
4. Многопоток превосходит однопоток на: 57,1% (всегда разница больше 15%)
